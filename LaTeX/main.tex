\documentclass[12pt,a4paper]{article}
\usepackage[a4paper,total={160mm,250mm}]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{ngerman}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{color}
\usepackage{mathtools}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{color}

\theoremstyle{definition}
\newtheorem{aufgabe}{Aufgabe}

\theoremstyle{definition}
\newtheorem*{losung*}{Lösung}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{lightgray}{rgb}{0.9,0.9,0.9}

\lstset{
	backgroundcolor=\color{lightgray},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
	basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	deletekeywords={...},            % if you want to delete keywords from the given language
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	firstnumber=1,                   % start line enumeration with line 1000
	frame=single,	                 % adds a frame around the code
	keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue},       % keyword style
	language=Python,                 % the language of the code
	morekeywords={*,...},            % if you want to add more keywords to the set
	numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
	numbersep=5pt,                   % how far the line-numbers are from the code
	numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          % underline spaces within strings only
	showtabs=false,                  % show tabs within strings adding particular underscores
	stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},     % string literal style
	tabsize=4,	                     % sets default tabsize to 2 spaces
	title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
	rangeprefix=\#---,
	rangesuffix=---,
	includerangemarker=false
}

\pagestyle{empty}

\begin{document}
	\section*{Was ist Raytracing?}
	Raytracing bezeichnet eine Methode zur Generierung von realistischen 3D Bildern.
	Dabei kommen unter anderem Reflexions- und Brechungsgesetze aus der Physik zur Anwendung.
	Vor allem aber beruht die Technik auf der Vektorgeometrie wie man sie am Gymnasium unterrichtet.
	Die Idee ist folgende: Wir verteilen einige Objekte (Kugeln, Würfel, etc.) im dreidimensionalen Raum.
	Wir nennen dies die Szene.
	Nun stellt man irgendwo eine Kamera auf.
	Vor der Kamera stellen wir uns eine rechteckige Fläche, die Bildebene, vor.
	Auf die Bildebene zeichnen wir nun die dahinter liegende Szene wie folgt:
	Ausgehend von der Kamera senden wir einen Strahl aus, der die Bildebene durchstösst und dann womöglich auf ein Objekt unserer Szene trifft.
	Trifft der Strahl zum Beispiel auf ein rotes Dreieck, so wird der Durchstosspunkt auf der Bildebene rot eingefärbt.
	Danach senden wir einen weiteren Strahl von der Kamera durch einen anderen Punkt auf der Bildebene und färben den Durchstosspunkt entsprechend ein.
	Wir wiederholen dies bis die ganze Bildebene eingefärbt ist.
	Das so auf der Bildebene generierte Abbild der Szene ist der Output unseres Programms.
	Diese Methode ein Bild zu generieren heisst Raytracing, denn man verfolgt den Strahl.
	\begin{figure}[h!]
		\centering
		\includegraphics[width=\textwidth]{images/raytracing.png}
		\caption{Raytracing: Es werden Strahlen ausgesendet und deren Schnittpunkte mit Objekten ermittelt. In diesem Fall wir der Durchstosspunkt auf der Bildebene in der Farbe des roten Dreiecks gefärbt.}
		\label{fig:raytracing}
	\end{figure}

	\section*{Worum geht es im Folgenden?}
	Wir wollen nun unser eigenes Raytracing-Programm in Python programmieren.
	Genauer gesagt ist der Raytracing-Algorithmus im Kern schon implementiert.
	Allerdings kennt diese Implementierung noch keine Objekte wie Kugeln, Würfel, Ebenen und so weiter.
	Hier kommen Sie als Leser ins Spiel.
	Sie werden unter Anleitung diese fehlenden Teile ergänzen.
	Es geht darum dem Raytracing-Programm zu sagen, was zum Beispiel eine Kugel ist, wie man deren Schnittpunkt mit einem Strahl berechnet und vieles mehr.
	Am Ende werden wir Bilder wie in Abbildung~\ref{fig:goal} generieren können.
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.75\textwidth]{images/image.png}
		\caption{Dieses Bild wurde mit unserem Raytracing-Programm generiert.}
		\label{fig:goal}
	\end{figure}
	Dabei müssen Sie als Leser ausschliesslich die Python-Files im Verzeichnis \texttt{object} editieren.
	Die darin enthaltenen Klassen werden dann die verschiedenen Objekt-Typen wie Kugeln, Ebenen und dergleichen beschreiben.
	Ohne hier weiter ins Detail zu gehen, werden wir nun unser erstes Bild generieren.

	\section*{Die Kugel}
	Als Einstieg generieren wir ein Bild bestehend aus folgender Szene:
	Eine Kamera befindet sich an den Koordinaten $(-1,0,1)$ und schaut in Richtung des Punktes $(0,0,1)$, das heisst entlang der x-Achse.
	Zudem platzieren wir eine Kugel mit Mittelpunkt $(1,0,1)$ und Radius $1$.
	Damit schaut die Kamera genau auf die Kugel.
	Diese Szene entspricht dem Python-File \texttt{examples/getting\_startet.py}, welches wir nun ausführen. Anstatt eine Kugel sehen wir aber nur ein schwarzes Bild.
	Um die Kugel auch zu sehen, müssen wir zuerst das File \texttt{myobject/sphere.py} bearbeiten.
	Genauer gesagt, muss die Funktion \texttt{intersect(self, ray)} vervollständigt werden.
	Diese soll zu einem gegebenen Strahl dessen nächstgelegenen Schnittpunkt berechnen.
	Man betrachte dazu Abbildung~\ref{fig:sphere_intersect}.
	\begin{figure}[ht]
		\centering
		\includegraphics[width=0.5\textwidth]{images/sphere_intersect.pdf}
		\caption{Schnittpunkt von Strahl und Kugel.}
		\label{fig:sphere_intersect}
	\end{figure}
	\begin{aufgabe}\label{aufg:intersect_theory}
		Gegeben Sei ein Strahl mit Ursprung $\vec{v}$ und Richtung $\vec{w}$.
		Überlegen Sie sich die Kugel mit Mittelpunkt $\vec{m}$ und Radius $r$ schneidet.
		Wie erhalten Sie in diesem Fall den Parameter $t>0$, so dass $\vec{v}+t\vec{w}$ gerade dem näherem der beiden Schnittpunkte entspricht?
	\end{aufgabe}
	\begin{losung*}
		Ein beliebiger Punkt auf dem Strahl ist von der Form $\vec{v}+s\vec{w}$ für ein $s>0$.
		So ein Punkt liegt auf der Kugeloberfläche genau dann wenn
		\begin{equation*}
			\lVert\vec{v}+s\vec{w}-\vec{m}\rVert^2=r^2,
		\end{equation*}
		also wenn er den Abstand $r$ zum Mittelpunkt hat.
		Dies ist eine quadratische Gleichung in $s$, das heisst sie ist von der Form
		\begin{equation*}
			as^2+bs+c=0
		\end{equation*}
		für reelle Zahlen $a,b$ und $c$.
		Durch einen Koeffizientenvergleich erhält man
		\begin{equation*}
			a=\rVert\vec{w}-\vec{m}\rVert^2,\quad
			b=2\vec{v}\cdot(\vec{w}-\vec{m}),\quad
			c=\lVert\vec{v}\rVert^2-r^2.
		\end{equation*}
		Falls $b^2-4ac>0$, so existieren genau zwei Schnittpunkte $v+t_1w$ und $v+t_2w$, wobei
		\begin{equation*}
			t_1=\frac{-b-\sqrt{b^2-4ac}}{2a}
			\quad\text{und}\quad
			t_2=\frac{-b+\sqrt{b^2-4ac}}{2a}.
		\end{equation*}
		Wir sind aber nur an positiven Lösungen interessiert, denn wir beschreiben einen Strahl und keine Gerade.
		Sind $t_1$ und $t_2$ beide negativ, so schneidet der Strahl die Kugel nicht.
		Andernfalls ist die kleinste positive Lösung der quadratischen Gleichung unsere Wahl für $t$.
		Der nächstgelegene Schnittpunkt ist entsprechend $v+tw$.
	\end{losung*}
	\begin{aufgabe}\label{aufg:intersect_implementation}
		Öffnen Sie nun das File \texttt{myobject/sphere.py} und implementieren Sie die Funktion \texttt{intersect(self, ray)} gemäss Ihren Überlegungen aus Aufgabe~\ref{aufg:intersect_theory}.
		Lassen Sie anschliessend das Skript \texttt{examples/getting\_startet.py} nochmals laufen.
		Nun sollten Sie die Kugel sehen.
	\end{aufgabe}
	\begin{losung*}
		Die Lösung könnte zum Beipiel so aussehen:
		\lstinputlisting[linerange=intersect-end]{../object/sphere.py}
		Zusätzlich zu unserer Lösung von Aufgabe~\ref{aufg:intersect_theory} haben wir hier noch überprüft, ob der Strahl am Schnittpunkt in die Kugel eintritt (und nicht etwa austritt).
		Nur diese Lösung lassen wir zu.
		Wir werden später sehen, warum das nützlich ist.
		Das so generierte Bild ist in Abbildung~\ref{fig:solution_sphere} gezeigt.
		\begin{figure}[ht]
			\centering
			\includegraphics[width=0.5\textwidth]{images/getting_started.png}
			\caption{Lösung der Aufgabe~\ref{aufg:intersect_implementation}.}
			\label{fig:solution_sphere}
		\end{figure}
	\end{losung*}
\end{document}
